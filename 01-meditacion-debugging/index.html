<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meditaci칩n como Debugging Mental</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Georgia', serif;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 350px;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            text-align: center;
        }
        
        #clarity-bar {
            width: 200px;
            height: 8px;
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        #clarity-progress {
            height: 100%;
            background: linear-gradient(90deg, #ff4757, #ffa502, #2ed573);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 4px;
        }
        
        .estado-caos { color: #ff4757 !important; }
        .estado-procesando { color: #ffa502 !important; }
        .estado-silencio { color: #2ed573 !important; }
    </style>
</head>
<body>
    <div id="info">
        <h3>游븾 Meditaci칩n como Debugging Mental</h3>
        <p><strong>Observa</strong> c칩mo los pensamientos par치sitos se disuelven</p>
        <p><strong>Click</strong> para acelerar el proceso de claridad</p>
        <p><strong>Mant칠n presionado</strong> para resetear la meditaci칩n</p>
        <p><em>La mente se purifica gradualmente...</em></p>
    </div>
    
    <div id="controls">
        <div id="estado-actual">Estado: Iniciando...</div>
        <div id="claridad-nivel">Claridad: 0%</div>
        <div id="clarity-bar">
            <div id="clarity-progress"></div>
        </div>
        <div id="pensamientos-count">Pensamientos: --</div>
    </div>

    <script>
        // === MEDITACI칍N COMO DEBUGGING MENTAL - VERSI칍N EXPANDIDA ===
        // Una experiencia visual del proceso de depuraci칩n de la conciencia
        
        let chakras = [];
        let pensamientos = [];
        let particulas = [];
        let ondas = [];
        let tiempo = 0;
        let claridad = 0; // 0 = Caos mental, 1 = Silencio
        let velocidadClaridad = 0.0003;
        let clickPresionado = false;
        let tiempoPresionado = 0;
        
        // Efectos visuales
        let auraParticulas = [];
        let interferencias = [];
        let momentosSilencio = [];
        
        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            
            // Inicializar chakras
            let coloresChakra = [0, 30, 60, 120, 210, 240, 275];
            let nombresChakra = ["Ra칤z", "Sacro", "Plexo", "Coraz칩n", "Garganta", "Tercer Ojo", "Corona"];
            
            for (let i = 0; i < 7; i++) {
                chakras.push({
                    y: (height * 0.85) - (i * height * 0.1),
                    color: coloresChakra[i],
                    nombre: nombresChakra[i],
                    tam: 25,
                    estabilidad: 0,
                    energia: random(0.3, 0.7),
                    ruido: random(1000)
                });
            }
            
            // Crear pensamientos par치sitos iniciales
            generarPensamientos();
            
            // Part칤culas del aura
            for (let i = 0; i < 50; i++) {
                auraParticulas.push({
                    angulo: random(TWO_PI),
                    radio: random(100, 300),
                    velocidad: random(0.005, 0.02),
                    tamano: random(2, 6),
                    opacidad: random(20, 60)
                });
            }
            
            // Interferencias mentales
            for (let i = 0; i < 20; i++) {
                interferencias.push({
                    x: random(width),
                    y: random(height * 0.1, height * 0.4),
                    intensidad: random(50, 100),
                    frecuencia: random(0.01, 0.05)
                });
            }
            
            textAlign(CENTER, CENTER);
            textFont('serif');
        }
        
        function draw() {
            // Fondo din치mico
            let fondoColor = lerpColor(
                color(240, 50, 8),  // Caos: rojo oscuro
                color(240, 20, 15), // Silencio: azul profundo
                claridad
            );
            background(fondoColor);
            
            tiempo += 0.015;
            
            // Actualizar claridad
            actualizarClaridad();
            
            // Capas de la experiencia
            dibujarInterferencias();
            dibujarAura();
            dibujarFiguraCentral();
            actualizarPensamientos();
            dibujarEfectosClaridad();
            dibujarMomentosSilencio();
            
            // Interfaz
            actualizarInterfaz();
        }
        
        function generarPensamientos() {
            pensamientos = [];
            let cantidad = lerp(200, 20, claridad);
            
            for (let i = 0; i < cantidad; i++) {
                pensamientos.push({
                    x: width / 2 + random(-200, 200),
                    y: height * 0.2 + random(-200, 200),
                    vx: random(-3, 3),
                    vy: random(-3, 3),
                    tam: random(3, 12),
                    ruidoOffset: random(1000),
                    tipo: random(['ansiedad', 'distraccion', 'preocupacion', 'ruido']),
                    intensidad: random(0.5, 1.0),
                    vida: 255
                });
            }
        }
        
        function actualizarClaridad() {
            // Velocidad base de claridad
            let velocidadBase = velocidadClaridad;
            
            // Acelerar con interacci칩n
            if (clickPresionado) {
                velocidadBase *= 3;
                tiempoPresionado++;
                
                // Reset si se mantiene presionado mucho tiempo
                if (tiempoPresionado > 180) { // 3 segundos
                    claridad = 0;
                    tiempoPresionado = 0;
                    generarPensamientos();
                    
                    // Crear efecto de reset
                    for (let i = 0; i < 20; i++) {
                        ondas.push({
                            x: width/2,
                            y: height/2,
                            radio: 0,
                            velocidad: random(3, 8),
                            color: 0,
                            alpha: 100
                        });
                    }
                }
            } else {
                tiempoPresionado = 0;
            }
            
            // Incrementar claridad
            claridad = min(1.0, claridad + velocidadBase);
            
            // Ajustar cantidad de pensamientos seg칰n claridad
            if (frameCount % 60 == 0 && claridad < 1.0) {
                let nuevaCantidad = lerp(200, 10, claridad);
                if (pensamientos.length > nuevaCantidad) {
                    pensamientos.splice(nuevaCantidad);
                }
            }
        }
        
        function dibujarInterferencias() {
            if (claridad < 0.7) {
                for (let interferencia of interferencias) {
                    interferencia.intensidad = lerp(interferencia.intensidad, 0, claridad);
                    
                    if (interferencia.intensidad > 5) {
                        stroke(0, 90, 90, interferencia.intensidad * (1 - claridad));
                        strokeWeight(random(0.5, 2));
                        
                        let x1 = interferencia.x + sin(tiempo * interferencia.frecuencia * 10) * 50;
                        let y1 = interferencia.y;
                        let x2 = interferencia.x + cos(tiempo * interferencia.frecuencia * 8) * 30;
                        let y2 = interferencia.y + random(-20, 20);
                        
                        line(x1, y1, x2, y2);
                    }
                }
            }
        }
        
        function dibujarAura() {
            push();
            translate(width/2, height/2);
            
            // Aura base que se expande y estabiliza
            let auraTam = lerp(width * 0.25, width * 0.5, claridad);
            let auraEstabilidad = lerp(50, 5, claridad);
            
            // M칰ltiples capas de aura
            for (let i = 1; i <= 6; i++) {
                let radio = auraTam + i * 20;
                let ruido = map(noise(tiempo * 0.5 + i), 0, 1, -auraEstabilidad, auraEstabilidad);
                
                noFill();
                stroke(200 + i * 10, lerp(80, 40, claridad), lerp(60, 100, claridad), lerp(8, 20, claridad));
                strokeWeight(i * 0.5);
                ellipse(0, 0, radio + ruido);
            }
            
            // Part칤culas del aura
            for (let p of auraParticulas) {
                p.angulo += p.velocidad;
                p.radio = lerp(p.radio, 150 + claridad * 100, 0.01);
                
                let x = cos(p.angulo) * p.radio;
                let y = sin(p.angulo) * p.radio;
                
                let particleOpacity = p.opacidad * claridad;
                fill(200, 50, 100, particleOpacity);
                noStroke();
                ellipse(x, y, p.tamano);
                
                // Conexiones entre part칤culas cercanas
                for (let other of auraParticulas) {
                    if (other != p) {
                        let otherX = cos(other.angulo) * other.radio;
                        let otherY = sin(other.angulo) * other.radio;
                        let d = dist(x, y, otherX, otherY);
                        
                        if (d < 80 && claridad > 0.3) {
                            stroke(200, 30, 100, claridad * 15);
                            strokeWeight(0.5);
                            line(x, y, otherX, otherY);
                        }
                    }
                }
            }
            
            pop();
        }
        
        function dibujarFiguraCentral() {
            // Columna de energ칤a central
            let columnaIntensidad = lerp(30, 90, claridad);
            let columnaGrosor = lerp(3, 8, claridad);
            
            stroke(0, 0, 100, columnaIntensidad);
            strokeWeight(columnaGrosor);
            line(width / 2, 0, width / 2, height);
            
            // Dibujar chakras
            for (let i = 0; i < chakras.length; i++) {
                let c = chakras[i];
                
                // Actualizar propiedades del chakra
                c.estabilidad = lerp(c.estabilidad, claridad, 0.05);
                c.energia = lerp(c.energia, 0.8 + claridad * 0.2, 0.02);
                
                // Pulso que se calma con la claridad
                let pulsoIntensidad = lerp(15, 3, claridad);
                let pulso = sin(tiempo * 3 - i) * pulsoIntensidad;
                let tamActual = c.tam + pulso;
                
                push();
                translate(width / 2, c.y);
                
                // 칍rbitas de energ칤a
                if (claridad > 0.2) {
                    for (let j = 0; j < 3; j++) {
                        let orbitaRadio = tamActual + 20 + j * 12;
                        let orbitaAngulo = tiempo * (0.5 + j * 0.2) + i;
                        
                        noFill();
                        stroke(c.color, 40, 80, claridad * 30);
                        strokeWeight(1);
                        ellipse(0, 0, orbitaRadio * 2);
                        
                        // Part칤cula orbital
                        let orbX = cos(orbitaAngulo) * orbitaRadio;
                        let orbY = sin(orbitaAngulo) * orbitaRadio;
                        fill(c.color, 70, 100, claridad * 60);
                        noStroke();
                        ellipse(orbX, orbY, 3);
                    }
                }
                
                // Aura del chakra
                let auraBrillo = lerp(40, 100, c.estabilidad);
                let auraSaturacion = lerp(60, 90, c.estabilidad);
                
                for (let j = 0; j < 4; j++) {
                    fill(c.color, auraSaturacion, auraBrillo, 8 - j * 2);
                    ellipse(0, 0, (tamActual + j * 10) * 3);
                }
                
                // N칰cleo del chakra
                fill(c.color, 90, auraBrillo, 90);
                ellipse(0, 0, tamActual);
                
                // Centro brillante
                fill(0, 0, 100, auraBrillo);
                ellipse(0, 0, tamActual * 0.3);
                
                // S칤mbolo del chakra en alta claridad
                if (claridad > 0.6) {
                    fill(0, 0, 100, claridad * 80);
                    textSize(8);
                    text(c.nombre.charAt(0), 0, 0);
                }
                
                pop();
            }
        }
        
        function actualizarPensamientos() {
            let cabezaY = height * 0.2;
            
            for (let i = pensamientos.length - 1; i >= 0; i--) {
                let p = pensamientos[i];
                
                // Movimiento ca칩tico que disminuye
                let fuerzaRuido = lerp(1.5, 0.05, claridad);
                p.vx += map(noise(p.ruidoOffset + tiempo), 0, 1, -0.2, 0.2) * fuerzaRuido;
                p.vy += map(noise(p.ruidoOffset + 100 + tiempo), 0, 1, -0.2, 0.2) * fuerzaRuido;
                
                p.x += p.vx;
                p.y += p.vy;
                
                // Atracci칩n hacia el centro para ser procesados
                let atraccion = lerp(0.005, 0.02, claridad);
                p.x = lerp(p.x, width/2, atraccion);
                p.y = lerp(p.y, cabezaY, atraccion);
                
                // Fricci칩n
                p.vx *= 0.98;
                p.vy *= 0.98;
                
                // Desvanecimiento
                p.vida = lerp(p.vida, 0, claridad * 0.02);
                
                // Dibujo del pensamiento
                if (p.vida > 5) {
                    push();
                    translate(p.x, p.y);
                    rotate(p.ruidoOffset + tiempo * 10 * (1 - claridad));
                    
                    // Color seg칰n tipo
                    let colorPensamiento;
                    switch(p.tipo) {
                        case 'ansiedad': colorPensamiento = 0; break;
                        case 'distraccion': colorPensamiento = 60; break;
                        case 'preocupacion': colorPensamiento = 30; break;
                        default: colorPensamiento = 300;
                    }
                    
                    strokeWeight(1.5);
                    stroke(colorPensamiento, 80, 80, p.vida * (1 - claridad));
                    noFill();
                    
                    // Forma angular representando el caos mental
                    beginShape();
                    for (let j = 0; j < 6; j++) {
                        let angulo = map(j, 0, 6, 0, TWO_PI);
                        let radio = p.tam + sin(tiempo * 5 + j) * 3;
                        vertex(cos(angulo) * radio, sin(angulo) * radio);
                    }
                    endShape(CLOSE);
                    
                    // L칤neas de interferencia
                    if (random() < 0.1) {
                        stroke(colorPensamiento, 90, 90, p.vida * 0.5);
                        strokeWeight(1);
                        line(0, 0, random(-p.tam, p.tam), random(-p.tam, p.tam));
                    }
                    
                    pop();
                }
                
                // Eliminar pensamientos disueltos
                if (p.vida <= 5) {
                    pensamientos.splice(i, 1);
                    
                    // Crear part칤cula de liberaci칩n
                    particulas.push({
                        x: p.x,
                        y: p.y,
                        vx: random(-2, 2),
                        vy: random(-4, -1),
                        vida: 60,
                        color: 200
                    });
                }
            }
            
            // Actualizar part칤culas de liberaci칩n
            for (let i = particulas.length - 1; i >= 0; i--) {
                let p = particulas[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vida--;
                
                fill(p.color, 60, 100, p.vida);
                noStroke();
                ellipse(p.x, p.y, 3);
                
                if (p.vida <= 0) {
                    particulas.splice(i, 1);
                }
            }
        }
        
        function dibujarEfectosClaridad() {
            // Ondas de paz cuando se alcanza alta claridad
            if (claridad > 0.8) {
                push();
                translate(width/2, height/2);
                
                for (let i = 0; i < 5; i++) {
                    let radio = 100 + i * 50 + sin(tiempo * 2 + i) * 20;
                    noFill();
                    stroke(200, 30, 100, 20 - i * 3);
                    strokeWeight(2);
                    ellipse(0, 0, radio);
                }
                
                pop();
            }
            
            // Actualizar ondas
            for (let i = ondas.length - 1; i >= 0; i--) {
                let onda = ondas[i];
                onda.radio += onda.velocidad;
                onda.alpha -= 2;
                
                noFill();
                stroke(onda.color, 80, 100, onda.alpha);
                strokeWeight(3);
                ellipse(onda.x, onda.y, onda.radio);
                
                if (onda.alpha <= 0) {
                    ondas.splice(i, 1);
                }
            }
        }
        
        function dibujarMomentosSilencio() {
            if (claridad > 0.95) {
                // Momento de silencio completo
                push();
                translate(width/2, height/2);
                
                fill(0, 0, 100, 40 + sin(tiempo * 2) * 20);
                textAlign(CENTER, CENTER);
                textSize(28);
                text("SILENCIO INTERIOR", 0, -50);
                
                textSize(16);
                text("Debugging Completo", 0, 50);
                
                // Efecto de luz pura
                for (let i = 0; i < 12; i++) {
                    let angulo = map(i, 0, 12, 0, TWO_PI);
                    let longitud = 150 + sin(tiempo * 3 + i) * 30;
                    
                    stroke(0, 0, 100, 30);
                    strokeWeight(2);
                    line(0, 0, cos(angulo) * longitud, sin(angulo) * longitud);
                }
                
                pop();
            }
        }
        
        function actualizarInterfaz() {
            let estado = "";
            if (claridad < 0.3) estado = "DEBUGGING MENTAL...";
            else if (claridad < 0.7) estado = "PROCESANDO...";
            else if (claridad < 0.95) estado = "CLARIFICANDO...";
            else estado = "SILENCIO INTERIOR";
            
            document.getElementById('estado-actual').textContent = `Estado: ${estado}`;
            document.getElementById('claridad-nivel').textContent = `Claridad: ${Math.round(claridad * 100)}%`;
            document.getElementById('pensamientos-count').textContent = `Pensamientos: ${pensamientos.length}`;
            
            // Actualizar barra de progreso
            let progressBar = document.getElementById('clarity-progress');
            progressBar.style.width = `${claridad * 100}%`;
            
            // Cambiar clase CSS seg칰n el estado
            let controlsDiv = document.getElementById('controls');
            if (claridad < 0.3) controlsDiv.className = 'estado-caos';
            else if (claridad < 0.8) controlsDiv.className = 'estado-procesando';
            else controlsDiv.className = 'estado-silencio';
        }
        
        function mousePressed() {
            clickPresionado = true;
            
            // Crear onda de claridad
            ondas.push({
                x: mouseX,
                y: mouseY,
                radio: 0,
                velocidad: 4,
                color: 200,
                alpha: 80
            });
        }
        
        function mouseReleased() {
            clickPresionado = false;
        }
        
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            
            // Reposicionar chakras
            for (let i = 0; i < 7; i++) {
                chakras[i].y = (height * 0.85) - (i * height * 0.1);
            }
            
            // Reposicionar pensamientos
            for (let p of pensamientos) {
                if (p.x > width || p.y > height) {
                    p.x = width / 2 + random(-200, 200);
                    p.y = height * 0.2 + random(-200, 200);
                }
            }
        }
    </script>
</body>
</html>
