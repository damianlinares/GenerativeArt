<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORÁCULO DEL ALMA - Por Damian Alejandro Linares</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100vh;
            background: #000;
            overflow: hidden;
            display: flex; align-items: center; justify-content: center;
        }
        canvas { display: block; }
        .input-container {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }
        #psychic-input {
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-family: 'Garamond', serif;
            font-size: 2em;
            text-align: center;
            width: 600px;
            padding: 10px;
            outline: none;
            transition: all 0.5s;
        }
        #psychic-input:focus {
            border-bottom-color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
        }
        #psychic-input::placeholder {
            color: rgba(255, 255, 255, 0.3);
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="input-container">
        <input type="text" id="psychic-input" placeholder="¿Qué pesa en tu alma?" autofocus>
    </div>
    <script>
        let particles = [];
        let inputElement;
        let isGenerating = false;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 360, 100, 100, 100);
            
            inputElement = document.getElementById('psychic-input');
            inputElement.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && inputElement.value.trim() !== '') {
                    generarSimbolo(inputElement.value);
                    inputElement.style.opacity = '0';
                    inputElement.style.pointerEvents = 'none';
                }
            });
        }

        function draw() {
            background(0, 0, 5, 80); // Fondo oscuro con un ligero rastro

            if (isGenerating) {
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].update();
                    particles[i].display();
                    if (particles[i].isDead()) {
                        particles.splice(i, 1);
                    }
                }
                if (particles.length === 0) {
                    isGenerating = false;
                    inputElement.value = '';
                    inputElement.style.opacity = '1';
                    inputElement.style.pointerEvents = 'auto';
                }
            }
        }

        function generarSimbolo(inputText) {
            particles = [];
            isGenerating = true;
            let seed = 0;
            for (let i = 0; i < inputText.length; i++) {
                seed += inputText.charCodeAt(i);
            }

            let numParticles = constrain(inputText.length * 50, 200, 2500);
            
            for (let i = 0; i < numParticles; i++) {
                let charIndex = i % inputText.length;
                let charCode = inputText.charCodeAt(charIndex);
                
                let p = new Particle(
                    width / 2, 
                    height / 2,
                    charCode, // Semilla de caracter para color y comportamiento
                    seed,     // Semilla de palabra completa
                    i,        // Indice de partícula
                    numParticles
                );
                particles.push(p);
            }
        }

        class Particle {
            constructor(x, y, charSeed, wordSeed, index, total) {
                this.pos = createVector(x, y);
                
                // --- Generación procedural basada en el input ---
                let angle = map(index, 0, total, 0, TWO_PI * (wordSeed % 7 + 1));
                let initialSpeed = map(charSeed, 65, 122, 5, 15); // A-z
                this.vel = p5.Vector.fromAngle(angle).mult(initialSpeed);
                
                this.lifespan = 255;
                
                // Color derivado del caracter
                this.hue = (charSeed * 2.5) % 360;
                this.saturation = 80 + (wordSeed % 20);
                this.brightness = 100;
                
                this.size = 2.5;
                
                this.mandalaAngle = angle;
                this.mandalaRadius = map(noise(index * 0.1, (wordSeed % 100) * 0.01), 0, 1, height * 0.1, height * 0.4);
            }

            isDead() {
                return this.lifespan < 0;
            }

            update() {
                // Comportamiento: explosión inicial y luego coalescencia en un mandala
                let targetPos = createVector(
                    width / 2 + cos(this.mandalaAngle) * this.mandalaRadius,
                    height / 2 + sin(this.mandalaAngle) * this.mandalaRadius
                );

                let force = p5.Vector.sub(targetPos, this.pos);
                force.mult(0.01);
                
                this.vel.add(force);
                this.vel.mult(0.97); // Fricción para estabilizarse
                this.pos.add(this.vel);

                this.lifespan -= 0.3;
            }

            display() {
                noStroke();
                
                // Efecto de estela / brillo
                let glowAlpha = map(this.lifespan, 255, 0, 50, 0);
                fill(this.hue, this.saturation, this.brightness, glowAlpha);
                ellipse(this.pos.x, this.pos.y, this.size * 5);

                // Núcleo
                let coreAlpha = map(this.lifespan, 255, 0, 100, 0);
                fill(this.hue, this.saturation - 20, this.brightness, coreAlpha);
                ellipse(this.pos.x, this.pos.y, this.size);
            }
        }
        
        function windowResized() { resizeCanvas(windowWidth, windowHeight); }
    </script>
</body>
</html>
